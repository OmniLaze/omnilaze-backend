"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SendSmsVerifyCodeResponseBody = exports.SendSmsVerifyCodeRequest = exports.QuerySendDetailsResponse = exports.QuerySendDetailsResponseBody = exports.QuerySendDetailsRequest = exports.QueryGateVerifyStatisticPublicResponse = exports.QueryGateVerifyStatisticPublicResponseBody = exports.QueryGateVerifyStatisticPublicRequest = exports.QueryGateVerifyBillingPublicResponse = exports.QueryGateVerifyBillingPublicResponseBody = exports.QueryGateVerifyBillingPublicRequest = exports.JyQueryAppInfoBySceneCodeResponse = exports.JyQueryAppInfoBySceneCodeResponseBody = exports.JyQueryAppInfoBySceneCodeRequest = exports.JyCreateVerifySchemeResponse = exports.JyCreateVerifySchemeResponseBody = exports.JyCreateVerifySchemeRequest = exports.GetSmsAuthTokensResponse = exports.GetSmsAuthTokensResponseBody = exports.GetSmsAuthTokensRequest = exports.GetPhoneWithTokenResponse = exports.GetPhoneWithTokenResponseBody = exports.GetPhoneWithTokenRequest = exports.GetMobileResponse = exports.GetMobileResponseBody = exports.GetMobileRequest = exports.GetFusionAuthTokenResponse = exports.GetFusionAuthTokenResponseBody = exports.GetFusionAuthTokenRequest = exports.GetAuthorizationUrlResponse = exports.GetAuthorizationUrlResponseBody = exports.GetAuthorizationUrlRequest = exports.GetAuthTokenResponse = exports.GetAuthTokenResponseBody = exports.GetAuthTokenRequest = exports.DescribeVerifySchemeResponse = exports.DescribeVerifySchemeResponseBody = exports.DescribeVerifySchemeRequest = exports.DeleteVerifySchemeResponse = exports.DeleteVerifySchemeResponseBody = exports.DeleteVerifySchemeRequest = exports.CreateVerifySchemeResponse = exports.CreateVerifySchemeResponseBody = exports.CreateVerifySchemeRequest = exports.CreateSchemeConfigResponse = exports.CreateSchemeConfigResponseBody = exports.CreateSchemeConfigRequest = exports.CheckSmsVerifyCodeResponse = exports.CheckSmsVerifyCodeResponseBody = exports.CheckSmsVerifyCodeRequest = void 0;
exports.VerifyWithFusionAuthTokenResponseBodyModel = exports.VerifyPhoneWithTokenResponseBodyGateVerify = exports.VerifyMobileResponseBodyGateVerifyResultDTO = exports.SendSmsVerifyCodeResponseBodyModel = exports.QuerySendDetailsResponseBodyModel = exports.QueryGateVerifyStatisticPublicResponseBodyData = exports.QueryGateVerifyStatisticPublicResponseBodyDataDayStatistic = exports.QueryGateVerifyBillingPublicResponseBodyData = exports.QueryGateVerifyBillingPublicResponseBodyDataSceneBillingList = exports.JyQueryAppInfoBySceneCodeResponseBodyData = exports.JyCreateVerifySchemeResponseBodyGateVerifySchemeData = exports.GetSmsAuthTokensResponseBodyData = exports.GetPhoneWithTokenResponseBodyData = exports.GetMobileResponseBodyGetMobileResultDTO = exports.GetAuthorizationUrlResponseBodyData = exports.GetAuthTokenResponseBodyTokenInfo = exports.DescribeVerifySchemeResponseBodySchemeQueryResultDTO = exports.CreateVerifySchemeResponseBodyGateVerifySchemeDTO = exports.CreateSchemeConfigResponseBodyModel = exports.CheckSmsVerifyCodeResponseBodyModel = exports.VerifyWithFusionAuthTokenResponse = exports.VerifyWithFusionAuthTokenResponseBody = exports.VerifyWithFusionAuthTokenRequest = exports.VerifySmsCodeResponse = exports.VerifySmsCodeResponseBody = exports.VerifySmsCodeRequest = exports.VerifyPhoneWithTokenResponse = exports.VerifyPhoneWithTokenResponseBody = exports.VerifyPhoneWithTokenRequest = exports.VerifyMobileResponse = exports.VerifyMobileResponseBody = exports.VerifyMobileRequest = exports.SendSmsVerifyCodeResponse = void 0;
// This file is auto-generated, don't edit it
/**
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const endpoint_util_1 = __importDefault(require("@alicloud/endpoint-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class CheckSmsVerifyCodeRequest extends $tea.Model {
    static names() {
        return {
            caseAuthPolicy: 'CaseAuthPolicy',
            countryCode: 'CountryCode',
            outId: 'OutId',
            ownerId: 'OwnerId',
            phoneNumber: 'PhoneNumber',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            schemeName: 'SchemeName',
            verifyCode: 'VerifyCode',
        };
    }
    static types() {
        return {
            caseAuthPolicy: 'number',
            countryCode: 'string',
            outId: 'string',
            ownerId: 'number',
            phoneNumber: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            schemeName: 'string',
            verifyCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckSmsVerifyCodeRequest = CheckSmsVerifyCodeRequest;
class CheckSmsVerifyCodeResponseBody extends $tea.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            message: 'Message',
            model: 'Model',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            message: 'string',
            model: CheckSmsVerifyCodeResponseBodyModel,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckSmsVerifyCodeResponseBody = CheckSmsVerifyCodeResponseBody;
class CheckSmsVerifyCodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckSmsVerifyCodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckSmsVerifyCodeResponse = CheckSmsVerifyCodeResponse;
class CreateSchemeConfigRequest extends $tea.Model {
    static names() {
        return {
            androidPackageName: 'AndroidPackageName',
            androidPackageSign: 'AndroidPackageSign',
            appName: 'AppName',
            h5Origin: 'H5Origin',
            h5Url: 'H5Url',
            iosBundleId: 'IosBundleId',
            ownerId: 'OwnerId',
            platform: 'Platform',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            schemeName: 'SchemeName',
        };
    }
    static types() {
        return {
            androidPackageName: 'string',
            androidPackageSign: 'string',
            appName: 'string',
            h5Origin: 'string',
            h5Url: 'string',
            iosBundleId: 'string',
            ownerId: 'number',
            platform: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            schemeName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSchemeConfigRequest = CreateSchemeConfigRequest;
class CreateSchemeConfigResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            model: 'Model',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            model: CreateSchemeConfigResponseBodyModel,
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSchemeConfigResponseBody = CreateSchemeConfigResponseBody;
class CreateSchemeConfigResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSchemeConfigResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSchemeConfigResponse = CreateSchemeConfigResponse;
class CreateVerifySchemeRequest extends $tea.Model {
    static names() {
        return {
            appName: 'AppName',
            authType: 'AuthType',
            bundleId: 'BundleId',
            cmApiCode: 'CmApiCode',
            ctApiCode: 'CtApiCode',
            cuApiCode: 'CuApiCode',
            email: 'Email',
            hmAppIdentifier: 'HmAppIdentifier',
            hmPackageName: 'HmPackageName',
            hmSignName: 'HmSignName',
            ipWhiteList: 'IpWhiteList',
            origin: 'Origin',
            osType: 'OsType',
            ownerId: 'OwnerId',
            packName: 'PackName',
            packSign: 'PackSign',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sceneType: 'SceneType',
            schemeName: 'SchemeName',
            smsSignName: 'SmsSignName',
            url: 'Url',
        };
    }
    static types() {
        return {
            appName: 'string',
            authType: 'string',
            bundleId: 'string',
            cmApiCode: 'number',
            ctApiCode: 'number',
            cuApiCode: 'number',
            email: 'string',
            hmAppIdentifier: 'string',
            hmPackageName: 'string',
            hmSignName: 'string',
            ipWhiteList: 'string',
            origin: 'string',
            osType: 'string',
            ownerId: 'number',
            packName: 'string',
            packSign: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sceneType: 'string',
            schemeName: 'string',
            smsSignName: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVerifySchemeRequest = CreateVerifySchemeRequest;
class CreateVerifySchemeResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            gateVerifySchemeDTO: 'GateVerifySchemeDTO',
            httpStatusCode: 'HttpStatusCode',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            gateVerifySchemeDTO: CreateVerifySchemeResponseBodyGateVerifySchemeDTO,
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVerifySchemeResponseBody = CreateVerifySchemeResponseBody;
class CreateVerifySchemeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateVerifySchemeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVerifySchemeResponse = CreateVerifySchemeResponse;
class DeleteVerifySchemeRequest extends $tea.Model {
    static names() {
        return {
            customerId: 'CustomerId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            schemeCode: 'SchemeCode',
        };
    }
    static types() {
        return {
            customerId: 'number',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            schemeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteVerifySchemeRequest = DeleteVerifySchemeRequest;
class DeleteVerifySchemeResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            result: 'Result',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteVerifySchemeResponseBody = DeleteVerifySchemeResponseBody;
class DeleteVerifySchemeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteVerifySchemeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteVerifySchemeResponse = DeleteVerifySchemeResponse;
class DescribeVerifySchemeRequest extends $tea.Model {
    static names() {
        return {
            customerId: 'CustomerId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            schemeCode: 'SchemeCode',
        };
    }
    static types() {
        return {
            customerId: 'number',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            schemeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DescribeVerifySchemeRequest = DescribeVerifySchemeRequest;
class DescribeVerifySchemeResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            schemeQueryResultDTO: 'SchemeQueryResultDTO',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            schemeQueryResultDTO: DescribeVerifySchemeResponseBodySchemeQueryResultDTO,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DescribeVerifySchemeResponseBody = DescribeVerifySchemeResponseBody;
class DescribeVerifySchemeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeVerifySchemeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DescribeVerifySchemeResponse = DescribeVerifySchemeResponse;
class GetAuthTokenRequest extends $tea.Model {
    static names() {
        return {
            bizType: 'BizType',
            cmApiCode: 'CmApiCode',
            ctApiCode: 'CtApiCode',
            cuApiCode: 'CuApiCode',
            origin: 'Origin',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sceneCode: 'SceneCode',
            url: 'Url',
            version: 'Version',
        };
    }
    static types() {
        return {
            bizType: 'number',
            cmApiCode: 'number',
            ctApiCode: 'number',
            cuApiCode: 'number',
            origin: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sceneCode: 'string',
            url: 'string',
            version: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthTokenRequest = GetAuthTokenRequest;
class GetAuthTokenResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            tokenInfo: 'TokenInfo',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            tokenInfo: GetAuthTokenResponseBodyTokenInfo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthTokenResponseBody = GetAuthTokenResponseBody;
class GetAuthTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAuthTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthTokenResponse = GetAuthTokenResponse;
class GetAuthorizationUrlRequest extends $tea.Model {
    static names() {
        return {
            endDate: 'EndDate',
            ownerId: 'OwnerId',
            phoneNo: 'PhoneNo',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            schemeId: 'SchemeId',
        };
    }
    static types() {
        return {
            endDate: 'string',
            ownerId: 'number',
            phoneNo: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            schemeId: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthorizationUrlRequest = GetAuthorizationUrlRequest;
class GetAuthorizationUrlResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetAuthorizationUrlResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthorizationUrlResponseBody = GetAuthorizationUrlResponseBody;
class GetAuthorizationUrlResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAuthorizationUrlResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthorizationUrlResponse = GetAuthorizationUrlResponse;
class GetFusionAuthTokenRequest extends $tea.Model {
    static names() {
        return {
            bundleId: 'BundleId',
            durationSeconds: 'DurationSeconds',
            ownerId: 'OwnerId',
            packageName: 'PackageName',
            packageSign: 'PackageSign',
            platform: 'Platform',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            schemeCode: 'SchemeCode',
        };
    }
    static types() {
        return {
            bundleId: 'string',
            durationSeconds: 'number',
            ownerId: 'number',
            packageName: 'string',
            packageSign: 'string',
            platform: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            schemeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFusionAuthTokenRequest = GetFusionAuthTokenRequest;
class GetFusionAuthTokenResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            model: 'Model',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            model: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFusionAuthTokenResponseBody = GetFusionAuthTokenResponseBody;
class GetFusionAuthTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFusionAuthTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFusionAuthTokenResponse = GetFusionAuthTokenResponse;
class GetMobileRequest extends $tea.Model {
    static names() {
        return {
            accessToken: 'AccessToken',
            outId: 'OutId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accessToken: 'string',
            outId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMobileRequest = GetMobileRequest;
class GetMobileResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            getMobileResultDTO: 'GetMobileResultDTO',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            getMobileResultDTO: GetMobileResponseBodyGetMobileResultDTO,
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMobileResponseBody = GetMobileResponseBody;
class GetMobileResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetMobileResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMobileResponse = GetMobileResponse;
class GetPhoneWithTokenRequest extends $tea.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            spToken: 'SpToken',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            spToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPhoneWithTokenRequest = GetPhoneWithTokenRequest;
class GetPhoneWithTokenResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetPhoneWithTokenResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPhoneWithTokenResponseBody = GetPhoneWithTokenResponseBody;
class GetPhoneWithTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetPhoneWithTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPhoneWithTokenResponse = GetPhoneWithTokenResponse;
class GetSmsAuthTokensRequest extends $tea.Model {
    static names() {
        return {
            bundleId: 'BundleId',
            expire: 'Expire',
            osType: 'OsType',
            ownerId: 'OwnerId',
            packageName: 'PackageName',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sceneCode: 'SceneCode',
            signName: 'SignName',
            smsCodeExpire: 'SmsCodeExpire',
            smsTemplateCode: 'SmsTemplateCode',
        };
    }
    static types() {
        return {
            bundleId: 'string',
            expire: 'number',
            osType: 'string',
            ownerId: 'number',
            packageName: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sceneCode: 'string',
            signName: 'string',
            smsCodeExpire: 'number',
            smsTemplateCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsAuthTokensRequest = GetSmsAuthTokensRequest;
class GetSmsAuthTokensResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetSmsAuthTokensResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsAuthTokensResponseBody = GetSmsAuthTokensResponseBody;
class GetSmsAuthTokensResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSmsAuthTokensResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsAuthTokensResponse = GetSmsAuthTokensResponse;
class JyCreateVerifySchemeRequest extends $tea.Model {
    static names() {
        return {
            appName: 'AppName',
            bundleId: 'BundleId',
            cmApiCode: 'CmApiCode',
            ctApiCode: 'CtApiCode',
            cuApiCode: 'CuApiCode',
            osType: 'OsType',
            ownerId: 'OwnerId',
            packName: 'PackName',
            packSign: 'PackSign',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            schemeName: 'SchemeName',
        };
    }
    static types() {
        return {
            appName: 'string',
            bundleId: 'string',
            cmApiCode: 'number',
            ctApiCode: 'number',
            cuApiCode: 'number',
            osType: 'string',
            ownerId: 'number',
            packName: 'string',
            packSign: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            schemeName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.JyCreateVerifySchemeRequest = JyCreateVerifySchemeRequest;
class JyCreateVerifySchemeResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            gateVerifySchemeData: 'GateVerifySchemeData',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            gateVerifySchemeData: JyCreateVerifySchemeResponseBodyGateVerifySchemeData,
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.JyCreateVerifySchemeResponseBody = JyCreateVerifySchemeResponseBody;
class JyCreateVerifySchemeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: JyCreateVerifySchemeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.JyCreateVerifySchemeResponse = JyCreateVerifySchemeResponse;
class JyQueryAppInfoBySceneCodeRequest extends $tea.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sceneCode: 'SceneCode',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sceneCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.JyQueryAppInfoBySceneCodeRequest = JyQueryAppInfoBySceneCodeRequest;
class JyQueryAppInfoBySceneCodeResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: JyQueryAppInfoBySceneCodeResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.JyQueryAppInfoBySceneCodeResponseBody = JyQueryAppInfoBySceneCodeResponseBody;
class JyQueryAppInfoBySceneCodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: JyQueryAppInfoBySceneCodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.JyQueryAppInfoBySceneCodeResponse = JyQueryAppInfoBySceneCodeResponse;
class QueryGateVerifyBillingPublicRequest extends $tea.Model {
    static names() {
        return {
            authenticationType: 'AuthenticationType',
            month: 'Month',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
        };
    }
    static types() {
        return {
            authenticationType: 'number',
            month: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGateVerifyBillingPublicRequest = QueryGateVerifyBillingPublicRequest;
class QueryGateVerifyBillingPublicResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryGateVerifyBillingPublicResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGateVerifyBillingPublicResponseBody = QueryGateVerifyBillingPublicResponseBody;
class QueryGateVerifyBillingPublicResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryGateVerifyBillingPublicResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGateVerifyBillingPublicResponse = QueryGateVerifyBillingPublicResponse;
class QueryGateVerifyStatisticPublicRequest extends $tea.Model {
    static names() {
        return {
            authenticationType: 'AuthenticationType',
            endDate: 'EndDate',
            osType: 'OsType',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            sceneCode: 'SceneCode',
            startDate: 'StartDate',
        };
    }
    static types() {
        return {
            authenticationType: 'number',
            endDate: 'string',
            osType: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            sceneCode: 'string',
            startDate: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGateVerifyStatisticPublicRequest = QueryGateVerifyStatisticPublicRequest;
class QueryGateVerifyStatisticPublicResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryGateVerifyStatisticPublicResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGateVerifyStatisticPublicResponseBody = QueryGateVerifyStatisticPublicResponseBody;
class QueryGateVerifyStatisticPublicResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryGateVerifyStatisticPublicResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGateVerifyStatisticPublicResponse = QueryGateVerifyStatisticPublicResponse;
class QuerySendDetailsRequest extends $tea.Model {
    static names() {
        return {
            bizId: 'BizId',
            currentPage: 'CurrentPage',
            ownerId: 'OwnerId',
            pageSize: 'PageSize',
            phoneNumber: 'PhoneNumber',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sendDate: 'SendDate',
        };
    }
    static types() {
        return {
            bizId: 'string',
            currentPage: 'number',
            ownerId: 'number',
            pageSize: 'number',
            phoneNumber: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sendDate: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendDetailsRequest = QuerySendDetailsRequest;
class QuerySendDetailsResponseBody extends $tea.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            message: 'Message',
            model: 'Model',
            success: 'Success',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            message: 'string',
            model: { 'type': 'array', 'itemType': QuerySendDetailsResponseBodyModel },
            success: 'boolean',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendDetailsResponseBody = QuerySendDetailsResponseBody;
class QuerySendDetailsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySendDetailsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendDetailsResponse = QuerySendDetailsResponse;
class SendSmsVerifyCodeRequest extends $tea.Model {
    static names() {
        return {
            codeLength: 'CodeLength',
            codeType: 'CodeType',
            countryCode: 'CountryCode',
            duplicatePolicy: 'DuplicatePolicy',
            interval: 'Interval',
            outId: 'OutId',
            ownerId: 'OwnerId',
            phoneNumber: 'PhoneNumber',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            returnVerifyCode: 'ReturnVerifyCode',
            schemeName: 'SchemeName',
            signName: 'SignName',
            smsUpExtendCode: 'SmsUpExtendCode',
            templateCode: 'TemplateCode',
            templateParam: 'TemplateParam',
            validTime: 'ValidTime',
        };
    }
    static types() {
        return {
            codeLength: 'number',
            codeType: 'number',
            countryCode: 'string',
            duplicatePolicy: 'number',
            interval: 'number',
            outId: 'string',
            ownerId: 'number',
            phoneNumber: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            returnVerifyCode: 'boolean',
            schemeName: 'string',
            signName: 'string',
            smsUpExtendCode: 'string',
            templateCode: 'string',
            templateParam: 'string',
            validTime: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendSmsVerifyCodeRequest = SendSmsVerifyCodeRequest;
class SendSmsVerifyCodeResponseBody extends $tea.Model {
    static names() {
        return {
            accessDeniedDetail: 'AccessDeniedDetail',
            code: 'Code',
            message: 'Message',
            model: 'Model',
            success: 'Success',
        };
    }
    static types() {
        return {
            accessDeniedDetail: 'string',
            code: 'string',
            message: 'string',
            model: SendSmsVerifyCodeResponseBodyModel,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendSmsVerifyCodeResponseBody = SendSmsVerifyCodeResponseBody;
class SendSmsVerifyCodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendSmsVerifyCodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendSmsVerifyCodeResponse = SendSmsVerifyCodeResponse;
class VerifyMobileRequest extends $tea.Model {
    static names() {
        return {
            accessCode: 'AccessCode',
            outId: 'OutId',
            ownerId: 'OwnerId',
            phoneNumber: 'PhoneNumber',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accessCode: 'string',
            outId: 'string',
            ownerId: 'number',
            phoneNumber: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyMobileRequest = VerifyMobileRequest;
class VerifyMobileResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            gateVerifyResultDTO: 'GateVerifyResultDTO',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            gateVerifyResultDTO: VerifyMobileResponseBodyGateVerifyResultDTO,
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyMobileResponseBody = VerifyMobileResponseBody;
class VerifyMobileResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: VerifyMobileResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyMobileResponse = VerifyMobileResponse;
class VerifyPhoneWithTokenRequest extends $tea.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            phoneNumber: 'PhoneNumber',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            spToken: 'SpToken',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            phoneNumber: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            spToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyPhoneWithTokenRequest = VerifyPhoneWithTokenRequest;
class VerifyPhoneWithTokenResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            gateVerify: 'GateVerify',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            gateVerify: VerifyPhoneWithTokenResponseBodyGateVerify,
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyPhoneWithTokenResponseBody = VerifyPhoneWithTokenResponseBody;
class VerifyPhoneWithTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: VerifyPhoneWithTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyPhoneWithTokenResponse = VerifyPhoneWithTokenResponse;
class VerifySmsCodeRequest extends $tea.Model {
    static names() {
        return {
            phoneNumber: 'PhoneNumber',
            smsCode: 'SmsCode',
            smsToken: 'SmsToken',
        };
    }
    static types() {
        return {
            phoneNumber: 'string',
            smsCode: 'string',
            smsToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifySmsCodeRequest = VerifySmsCodeRequest;
class VerifySmsCodeResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifySmsCodeResponseBody = VerifySmsCodeResponseBody;
class VerifySmsCodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: VerifySmsCodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifySmsCodeResponse = VerifySmsCodeResponse;
class VerifyWithFusionAuthTokenRequest extends $tea.Model {
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            verifyToken: 'VerifyToken',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            verifyToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyWithFusionAuthTokenRequest = VerifyWithFusionAuthTokenRequest;
class VerifyWithFusionAuthTokenResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            model: 'Model',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            model: VerifyWithFusionAuthTokenResponseBodyModel,
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyWithFusionAuthTokenResponseBody = VerifyWithFusionAuthTokenResponseBody;
class VerifyWithFusionAuthTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: VerifyWithFusionAuthTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyWithFusionAuthTokenResponse = VerifyWithFusionAuthTokenResponse;
class CheckSmsVerifyCodeResponseBodyModel extends $tea.Model {
    static names() {
        return {
            outId: 'OutId',
            verifyResult: 'VerifyResult',
        };
    }
    static types() {
        return {
            outId: 'string',
            verifyResult: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckSmsVerifyCodeResponseBodyModel = CheckSmsVerifyCodeResponseBodyModel;
class CreateSchemeConfigResponseBodyModel extends $tea.Model {
    static names() {
        return {
            schemeCode: 'SchemeCode',
        };
    }
    static types() {
        return {
            schemeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSchemeConfigResponseBodyModel = CreateSchemeConfigResponseBodyModel;
class CreateVerifySchemeResponseBodyGateVerifySchemeDTO extends $tea.Model {
    static names() {
        return {
            schemeCode: 'SchemeCode',
        };
    }
    static types() {
        return {
            schemeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVerifySchemeResponseBodyGateVerifySchemeDTO = CreateVerifySchemeResponseBodyGateVerifySchemeDTO;
class DescribeVerifySchemeResponseBodySchemeQueryResultDTO extends $tea.Model {
    static names() {
        return {
            appEncryptInfo: 'AppEncryptInfo',
        };
    }
    static types() {
        return {
            appEncryptInfo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DescribeVerifySchemeResponseBodySchemeQueryResultDTO = DescribeVerifySchemeResponseBodySchemeQueryResultDTO;
class GetAuthTokenResponseBodyTokenInfo extends $tea.Model {
    static names() {
        return {
            accessToken: 'AccessToken',
            jwtToken: 'JwtToken',
        };
    }
    static types() {
        return {
            accessToken: 'string',
            jwtToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthTokenResponseBodyTokenInfo = GetAuthTokenResponseBodyTokenInfo;
class GetAuthorizationUrlResponseBodyData extends $tea.Model {
    static names() {
        return {
            authorizationUrl: 'AuthorizationUrl',
        };
    }
    static types() {
        return {
            authorizationUrl: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthorizationUrlResponseBodyData = GetAuthorizationUrlResponseBodyData;
class GetMobileResponseBodyGetMobileResultDTO extends $tea.Model {
    static names() {
        return {
            mobile: 'Mobile',
        };
    }
    static types() {
        return {
            mobile: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMobileResponseBodyGetMobileResultDTO = GetMobileResponseBodyGetMobileResultDTO;
class GetPhoneWithTokenResponseBodyData extends $tea.Model {
    static names() {
        return {
            mobile: 'Mobile',
        };
    }
    static types() {
        return {
            mobile: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPhoneWithTokenResponseBodyData = GetPhoneWithTokenResponseBodyData;
class GetSmsAuthTokensResponseBodyData extends $tea.Model {
    static names() {
        return {
            bizToken: 'BizToken',
            expireTime: 'ExpireTime',
            stsAccessKeyId: 'StsAccessKeyId',
            stsAccessKeySecret: 'StsAccessKeySecret',
            stsToken: 'StsToken',
        };
    }
    static types() {
        return {
            bizToken: 'string',
            expireTime: 'number',
            stsAccessKeyId: 'string',
            stsAccessKeySecret: 'string',
            stsToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSmsAuthTokensResponseBodyData = GetSmsAuthTokensResponseBodyData;
class JyCreateVerifySchemeResponseBodyGateVerifySchemeData extends $tea.Model {
    static names() {
        return {
            schemeCode: 'SchemeCode',
        };
    }
    static types() {
        return {
            schemeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.JyCreateVerifySchemeResponseBodyGateVerifySchemeData = JyCreateVerifySchemeResponseBodyGateVerifySchemeData;
class JyQueryAppInfoBySceneCodeResponseBodyData extends $tea.Model {
    static names() {
        return {
            cmAppId: 'CmAppId',
            cmAppKey: 'CmAppKey',
            ctAppId: 'CtAppId',
            ctAppKey: 'CtAppKey',
        };
    }
    static types() {
        return {
            cmAppId: 'string',
            cmAppKey: 'string',
            ctAppId: 'string',
            ctAppKey: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.JyQueryAppInfoBySceneCodeResponseBodyData = JyQueryAppInfoBySceneCodeResponseBodyData;
class QueryGateVerifyBillingPublicResponseBodyDataSceneBillingList extends $tea.Model {
    static names() {
        return {
            add: 'Add',
            amount: 'Amount',
            appName: 'AppName',
            itemName: 'ItemName',
            sceneCode: 'SceneCode',
            sceneName: 'SceneName',
            singlePrice: 'SinglePrice',
        };
    }
    static types() {
        return {
            add: 'string',
            amount: 'string',
            appName: 'string',
            itemName: 'string',
            sceneCode: 'string',
            sceneName: 'string',
            singlePrice: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGateVerifyBillingPublicResponseBodyDataSceneBillingList = QueryGateVerifyBillingPublicResponseBodyDataSceneBillingList;
class QueryGateVerifyBillingPublicResponseBodyData extends $tea.Model {
    static names() {
        return {
            amountSum: 'AmountSum',
            sceneBillingList: 'SceneBillingList',
        };
    }
    static types() {
        return {
            amountSum: 'string',
            sceneBillingList: { 'type': 'array', 'itemType': QueryGateVerifyBillingPublicResponseBodyDataSceneBillingList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGateVerifyBillingPublicResponseBodyData = QueryGateVerifyBillingPublicResponseBodyData;
class QueryGateVerifyStatisticPublicResponseBodyDataDayStatistic extends $tea.Model {
    static names() {
        return {
            statisticDateStr: 'StatisticDateStr',
            totalFail: 'TotalFail',
            totalSuccess: 'TotalSuccess',
            totalUnknown: 'TotalUnknown',
        };
    }
    static types() {
        return {
            statisticDateStr: 'string',
            totalFail: 'number',
            totalSuccess: 'number',
            totalUnknown: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGateVerifyStatisticPublicResponseBodyDataDayStatistic = QueryGateVerifyStatisticPublicResponseBodyDataDayStatistic;
class QueryGateVerifyStatisticPublicResponseBodyData extends $tea.Model {
    static names() {
        return {
            dayStatistic: 'DayStatistic',
            total: 'Total',
            totalFail: 'TotalFail',
            totalSuccess: 'TotalSuccess',
            totalUnknown: 'TotalUnknown',
        };
    }
    static types() {
        return {
            dayStatistic: { 'type': 'array', 'itemType': QueryGateVerifyStatisticPublicResponseBodyDataDayStatistic },
            total: 'number',
            totalFail: 'number',
            totalSuccess: 'number',
            totalUnknown: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGateVerifyStatisticPublicResponseBodyData = QueryGateVerifyStatisticPublicResponseBodyData;
class QuerySendDetailsResponseBodyModel extends $tea.Model {
    static names() {
        return {
            content: 'Content',
            errCode: 'ErrCode',
            outId: 'OutId',
            phoneNum: 'PhoneNum',
            receiveDate: 'ReceiveDate',
            sendDate: 'SendDate',
            sendStatus: 'SendStatus',
            templateCode: 'TemplateCode',
        };
    }
    static types() {
        return {
            content: 'string',
            errCode: 'string',
            outId: 'string',
            phoneNum: 'string',
            receiveDate: 'string',
            sendDate: 'string',
            sendStatus: 'number',
            templateCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendDetailsResponseBodyModel = QuerySendDetailsResponseBodyModel;
class SendSmsVerifyCodeResponseBodyModel extends $tea.Model {
    static names() {
        return {
            bizId: 'BizId',
            outId: 'OutId',
            requestId: 'RequestId',
            verifyCode: 'VerifyCode',
        };
    }
    static types() {
        return {
            bizId: 'string',
            outId: 'string',
            requestId: 'string',
            verifyCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendSmsVerifyCodeResponseBodyModel = SendSmsVerifyCodeResponseBodyModel;
class VerifyMobileResponseBodyGateVerifyResultDTO extends $tea.Model {
    static names() {
        return {
            verifyId: 'VerifyId',
            verifyResult: 'VerifyResult',
        };
    }
    static types() {
        return {
            verifyId: 'string',
            verifyResult: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyMobileResponseBodyGateVerifyResultDTO = VerifyMobileResponseBodyGateVerifyResultDTO;
class VerifyPhoneWithTokenResponseBodyGateVerify extends $tea.Model {
    static names() {
        return {
            verifyId: 'VerifyId',
            verifyResult: 'VerifyResult',
        };
    }
    static types() {
        return {
            verifyId: 'string',
            verifyResult: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyPhoneWithTokenResponseBodyGateVerify = VerifyPhoneWithTokenResponseBodyGateVerify;
class VerifyWithFusionAuthTokenResponseBodyModel extends $tea.Model {
    static names() {
        return {
            phoneNumber: 'PhoneNumber',
            phoneScore: 'PhoneScore',
            verifyResult: 'VerifyResult',
        };
    }
    static types() {
        return {
            phoneNumber: 'string',
            phoneScore: 'number',
            verifyResult: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.VerifyWithFusionAuthTokenResponseBodyModel = VerifyWithFusionAuthTokenResponseBodyModel;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._signatureAlgorithm = "v2";
        this._endpointRule = "central";
        this.checkConfig(config);
        this._endpoint = this.getEndpoint("dypnsapi", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!tea_util_1.default.empty(endpoint)) {
            return endpoint;
        }
        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    /**
     * Verifies SMS verification codes.
     *
     * @param request - CheckSmsVerifyCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CheckSmsVerifyCodeResponse
     */
    async checkSmsVerifyCodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.caseAuthPolicy)) {
            query["CaseAuthPolicy"] = request.caseAuthPolicy;
        }
        if (!tea_util_1.default.isUnset(request.countryCode)) {
            query["CountryCode"] = request.countryCode;
        }
        if (!tea_util_1.default.isUnset(request.outId)) {
            query["OutId"] = request.outId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.phoneNumber)) {
            query["PhoneNumber"] = request.phoneNumber;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.schemeName)) {
            query["SchemeName"] = request.schemeName;
        }
        if (!tea_util_1.default.isUnset(request.verifyCode)) {
            query["VerifyCode"] = request.verifyCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CheckSmsVerifyCode",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CheckSmsVerifyCodeResponse({}));
    }
    /**
     * Verifies SMS verification codes.
     *
     * @param request - CheckSmsVerifyCodeRequest
     * @returns CheckSmsVerifyCodeResponse
     */
    async checkSmsVerifyCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.checkSmsVerifyCodeWithOptions(request, runtime);
    }
    /**
     * Creates a code for a converged communication authentication service.
     *
     * @param request - CreateSchemeConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateSchemeConfigResponse
     */
    async createSchemeConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.androidPackageName)) {
            query["AndroidPackageName"] = request.androidPackageName;
        }
        if (!tea_util_1.default.isUnset(request.androidPackageSign)) {
            query["AndroidPackageSign"] = request.androidPackageSign;
        }
        if (!tea_util_1.default.isUnset(request.appName)) {
            query["AppName"] = request.appName;
        }
        if (!tea_util_1.default.isUnset(request.h5Origin)) {
            query["H5Origin"] = request.h5Origin;
        }
        if (!tea_util_1.default.isUnset(request.h5Url)) {
            query["H5Url"] = request.h5Url;
        }
        if (!tea_util_1.default.isUnset(request.iosBundleId)) {
            query["IosBundleId"] = request.iosBundleId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.platform)) {
            query["Platform"] = request.platform;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.schemeName)) {
            query["SchemeName"] = request.schemeName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateSchemeConfig",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateSchemeConfigResponse({}));
    }
    /**
     * Creates a code for a converged communication authentication service.
     *
     * @param request - CreateSchemeConfigRequest
     * @returns CreateSchemeConfigResponse
     */
    async createSchemeConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createSchemeConfigWithOptions(request, runtime);
    }
    /**
     * Creates a verification service.
     *
     * @remarks
     * ### [](#qps)QPS limits
     * You can call this operation up to 100 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - CreateVerifySchemeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateVerifySchemeResponse
     */
    async createVerifySchemeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appName)) {
            query["AppName"] = request.appName;
        }
        if (!tea_util_1.default.isUnset(request.authType)) {
            query["AuthType"] = request.authType;
        }
        if (!tea_util_1.default.isUnset(request.bundleId)) {
            query["BundleId"] = request.bundleId;
        }
        if (!tea_util_1.default.isUnset(request.cmApiCode)) {
            query["CmApiCode"] = request.cmApiCode;
        }
        if (!tea_util_1.default.isUnset(request.ctApiCode)) {
            query["CtApiCode"] = request.ctApiCode;
        }
        if (!tea_util_1.default.isUnset(request.cuApiCode)) {
            query["CuApiCode"] = request.cuApiCode;
        }
        if (!tea_util_1.default.isUnset(request.email)) {
            query["Email"] = request.email;
        }
        if (!tea_util_1.default.isUnset(request.hmAppIdentifier)) {
            query["HmAppIdentifier"] = request.hmAppIdentifier;
        }
        if (!tea_util_1.default.isUnset(request.hmPackageName)) {
            query["HmPackageName"] = request.hmPackageName;
        }
        if (!tea_util_1.default.isUnset(request.hmSignName)) {
            query["HmSignName"] = request.hmSignName;
        }
        if (!tea_util_1.default.isUnset(request.ipWhiteList)) {
            query["IpWhiteList"] = request.ipWhiteList;
        }
        if (!tea_util_1.default.isUnset(request.origin)) {
            query["Origin"] = request.origin;
        }
        if (!tea_util_1.default.isUnset(request.osType)) {
            query["OsType"] = request.osType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.packName)) {
            query["PackName"] = request.packName;
        }
        if (!tea_util_1.default.isUnset(request.packSign)) {
            query["PackSign"] = request.packSign;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sceneType)) {
            query["SceneType"] = request.sceneType;
        }
        if (!tea_util_1.default.isUnset(request.schemeName)) {
            query["SchemeName"] = request.schemeName;
        }
        if (!tea_util_1.default.isUnset(request.smsSignName)) {
            query["SmsSignName"] = request.smsSignName;
        }
        if (!tea_util_1.default.isUnset(request.url)) {
            query["Url"] = request.url;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateVerifyScheme",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateVerifySchemeResponse({}));
    }
    /**
     * Creates a verification service.
     *
     * @remarks
     * ### [](#qps)QPS limits
     * You can call this operation up to 100 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - CreateVerifySchemeRequest
     * @returns CreateVerifySchemeResponse
     */
    async createVerifyScheme(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createVerifySchemeWithOptions(request, runtime);
    }
    /**
     * Deletes a verification service.
     *
     * @remarks
     * ### [](#qps)QPS limits
     * You can call this operation up to 100 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DeleteVerifySchemeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteVerifySchemeResponse
     */
    async deleteVerifySchemeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.customerId)) {
            query["CustomerId"] = request.customerId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.schemeCode)) {
            query["SchemeCode"] = request.schemeCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteVerifyScheme",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteVerifySchemeResponse({}));
    }
    /**
     * Deletes a verification service.
     *
     * @remarks
     * ### [](#qps)QPS limits
     * You can call this operation up to 100 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DeleteVerifySchemeRequest
     * @returns DeleteVerifySchemeResponse
     */
    async deleteVerifyScheme(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteVerifySchemeWithOptions(request, runtime);
    }
    /**
     * Queries the details of a verification service.
     *
     * @remarks
     * ### [](#qps)QPS limits
     * You can call this operation up to 100 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DescribeVerifySchemeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DescribeVerifySchemeResponse
     */
    async describeVerifySchemeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.customerId)) {
            query["CustomerId"] = request.customerId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.schemeCode)) {
            query["SchemeCode"] = request.schemeCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeVerifyScheme",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeVerifySchemeResponse({}));
    }
    /**
     * Queries the details of a verification service.
     *
     * @remarks
     * ### [](#qps)QPS limits
     * You can call this operation up to 100 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - DescribeVerifySchemeRequest
     * @returns DescribeVerifySchemeResponse
     */
    async describeVerifyScheme(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeVerifySchemeWithOptions(request, runtime);
    }
    /**
     * Obtains the authorization token used for the authentication of the phone number verification for HTML5 pages. You can obtain AccessToken and JwtToken after a successful call.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Use the phone number verification feature for HTML5 pages](https://help.aliyun.com/document_detail/169786.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetAuthTokenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetAuthTokenResponse
     */
    async getAuthTokenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            query["BizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.cmApiCode)) {
            query["CmApiCode"] = request.cmApiCode;
        }
        if (!tea_util_1.default.isUnset(request.ctApiCode)) {
            query["CtApiCode"] = request.ctApiCode;
        }
        if (!tea_util_1.default.isUnset(request.cuApiCode)) {
            query["CuApiCode"] = request.cuApiCode;
        }
        if (!tea_util_1.default.isUnset(request.origin)) {
            query["Origin"] = request.origin;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sceneCode)) {
            query["SceneCode"] = request.sceneCode;
        }
        if (!tea_util_1.default.isUnset(request.url)) {
            query["Url"] = request.url;
        }
        if (!tea_util_1.default.isUnset(request.version)) {
            query["Version"] = request.version;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetAuthToken",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetAuthTokenResponse({}));
    }
    /**
     * Obtains the authorization token used for the authentication of the phone number verification for HTML5 pages. You can obtain AccessToken and JwtToken after a successful call.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Use the phone number verification feature for HTML5 pages](https://help.aliyun.com/document_detail/169786.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetAuthTokenRequest
     * @returns GetAuthTokenResponse
     */
    async getAuthToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getAuthTokenWithOptions(request, runtime);
    }
    /**
     * Obtains the URL for the Alipay account authorization.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account and obtain an Alibaba Cloud AccessKey pair. For more information, see [Process of communication authorization](https://help.aliyun.com/document_detail/196922.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetAuthorizationUrlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetAuthorizationUrlResponse
     */
    async getAuthorizationUrlWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.endDate)) {
            query["EndDate"] = request.endDate;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.phoneNo)) {
            query["PhoneNo"] = request.phoneNo;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.schemeId)) {
            query["SchemeId"] = request.schemeId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetAuthorizationUrl",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetAuthorizationUrlResponse({}));
    }
    /**
     * Obtains the URL for the Alipay account authorization.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account and obtain an Alibaba Cloud AccessKey pair. For more information, see [Process of communication authorization](https://help.aliyun.com/document_detail/196922.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetAuthorizationUrlRequest
     * @returns GetAuthorizationUrlResponse
     */
    async getAuthorizationUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getAuthorizationUrlWithOptions(request, runtime);
    }
    /**
     * Obtains the verification results by using the token that is obtained from the client SDKs.
     *
     * @param request - GetFusionAuthTokenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetFusionAuthTokenResponse
     */
    async getFusionAuthTokenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bundleId)) {
            query["BundleId"] = request.bundleId;
        }
        if (!tea_util_1.default.isUnset(request.durationSeconds)) {
            query["DurationSeconds"] = request.durationSeconds;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.packageName)) {
            query["PackageName"] = request.packageName;
        }
        if (!tea_util_1.default.isUnset(request.packageSign)) {
            query["PackageSign"] = request.packageSign;
        }
        if (!tea_util_1.default.isUnset(request.platform)) {
            query["Platform"] = request.platform;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.schemeCode)) {
            query["SchemeCode"] = request.schemeCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetFusionAuthToken",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetFusionAuthTokenResponse({}));
    }
    /**
     * Obtains the verification results by using the token that is obtained from the client SDKs.
     *
     * @param request - GetFusionAuthTokenRequest
     * @returns GetFusionAuthTokenResponse
     */
    async getFusionAuthToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getFusionAuthTokenWithOptions(request, runtime);
    }
    /**
     * Obtains a phone number for one-click logon.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Getting Started](https://help.aliyun.com/document_detail/84541.html).
     * >  This operation is applicable only to one-click logon or registration. You can call this operation only after you confirm the authorization on the authorization page provided by the SDK for one-click logon. You are prohibited from simulating or bypassing the authorization process. Alibaba Cloud reserves the right to terminate our services and take legal actions against such violations.
     * ### [](#qps)QPS limits
     * You can call this operation up to 5,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetMobileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetMobileResponse
     */
    async getMobileWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accessToken)) {
            query["AccessToken"] = request.accessToken;
        }
        if (!tea_util_1.default.isUnset(request.outId)) {
            query["OutId"] = request.outId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetMobile",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetMobileResponse({}));
    }
    /**
     * Obtains a phone number for one-click logon.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Getting Started](https://help.aliyun.com/document_detail/84541.html).
     * >  This operation is applicable only to one-click logon or registration. You can call this operation only after you confirm the authorization on the authorization page provided by the SDK for one-click logon. You are prohibited from simulating or bypassing the authorization process. Alibaba Cloud reserves the right to terminate our services and take legal actions against such violations.
     * ### [](#qps)QPS limits
     * You can call this operation up to 5,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetMobileRequest
     * @returns GetMobileResponse
     */
    async getMobile(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getMobileWithOptions(request, runtime);
    }
    /**
     * Obtains a phone number for one-click logon. This operation is exclusive to HTML5 pages.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Getting Started](https://help.aliyun.com/document_detail/84541.html).
     * >  This operation is applicable only to one-click logon or registration in HTML5 pages. You can call this operation only after you confirm the authorization on the authorization page provided by the JavaScript SDK. You are prohibited from simulating or bypassing the authorization process. Alibaba Cloud reserves the right to terminate our services and take legal actions against such violations.
     * ### [](#qps)QPS limits
     * You can call this operation up to 500 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetPhoneWithTokenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetPhoneWithTokenResponse
     */
    async getPhoneWithTokenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.spToken)) {
            query["SpToken"] = request.spToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetPhoneWithToken",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetPhoneWithTokenResponse({}));
    }
    /**
     * Obtains a phone number for one-click logon. This operation is exclusive to HTML5 pages.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Getting Started](https://help.aliyun.com/document_detail/84541.html).
     * >  This operation is applicable only to one-click logon or registration in HTML5 pages. You can call this operation only after you confirm the authorization on the authorization page provided by the JavaScript SDK. You are prohibited from simulating or bypassing the authorization process. Alibaba Cloud reserves the right to terminate our services and take legal actions against such violations.
     * ### [](#qps)QPS limits
     * You can call this operation up to 500 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetPhoneWithTokenRequest
     * @returns GetPhoneWithTokenResponse
     */
    async getPhoneWithToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getPhoneWithTokenWithOptions(request, runtime);
    }
    /**
     * Obtains the authorization token for an SMS verification code.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Use the SMS verification feature](https://help.aliyun.com/document_detail/313209.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 5,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetSmsAuthTokensRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetSmsAuthTokensResponse
     */
    async getSmsAuthTokensWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bundleId)) {
            query["BundleId"] = request.bundleId;
        }
        if (!tea_util_1.default.isUnset(request.expire)) {
            query["Expire"] = request.expire;
        }
        if (!tea_util_1.default.isUnset(request.osType)) {
            query["OsType"] = request.osType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.packageName)) {
            query["PackageName"] = request.packageName;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sceneCode)) {
            query["SceneCode"] = request.sceneCode;
        }
        if (!tea_util_1.default.isUnset(request.signName)) {
            query["SignName"] = request.signName;
        }
        if (!tea_util_1.default.isUnset(request.smsCodeExpire)) {
            query["SmsCodeExpire"] = request.smsCodeExpire;
        }
        if (!tea_util_1.default.isUnset(request.smsTemplateCode)) {
            query["SmsTemplateCode"] = request.smsTemplateCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetSmsAuthTokens",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetSmsAuthTokensResponse({}));
    }
    /**
     * Obtains the authorization token for an SMS verification code.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Use the SMS verification feature](https://help.aliyun.com/document_detail/313209.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 5,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - GetSmsAuthTokensRequest
     * @returns GetSmsAuthTokensResponse
     */
    async getSmsAuthTokens(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getSmsAuthTokensWithOptions(request, runtime);
    }
    /**
     * 创建方案号（为极意临时定制）
     *
     * @deprecated OpenAPI JyCreateVerifyScheme is deprecated, please use Dypnsapi::2017-05-25::CreateVerifyScheme instead.
     *
     * @param request - JyCreateVerifySchemeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns JyCreateVerifySchemeResponse
     */
    // Deprecated
    async jyCreateVerifySchemeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appName)) {
            query["AppName"] = request.appName;
        }
        if (!tea_util_1.default.isUnset(request.bundleId)) {
            query["BundleId"] = request.bundleId;
        }
        if (!tea_util_1.default.isUnset(request.cmApiCode)) {
            query["CmApiCode"] = request.cmApiCode;
        }
        if (!tea_util_1.default.isUnset(request.ctApiCode)) {
            query["CtApiCode"] = request.ctApiCode;
        }
        if (!tea_util_1.default.isUnset(request.cuApiCode)) {
            query["CuApiCode"] = request.cuApiCode;
        }
        if (!tea_util_1.default.isUnset(request.osType)) {
            query["OsType"] = request.osType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.packName)) {
            query["PackName"] = request.packName;
        }
        if (!tea_util_1.default.isUnset(request.packSign)) {
            query["PackSign"] = request.packSign;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.schemeName)) {
            query["SchemeName"] = request.schemeName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "JyCreateVerifyScheme",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new JyCreateVerifySchemeResponse({}));
    }
    /**
     * 创建方案号（为极意临时定制）
     *
     * @deprecated OpenAPI JyCreateVerifyScheme is deprecated, please use Dypnsapi::2017-05-25::CreateVerifyScheme instead.
     *
     * @param request - JyCreateVerifySchemeRequest
     * @returns JyCreateVerifySchemeResponse
     */
    // Deprecated
    async jyCreateVerifyScheme(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.jyCreateVerifySchemeWithOptions(request, runtime);
    }
    /**
     * 根据方案号查询运营商APP信（为极意临时定制）
     *
     * @deprecated OpenAPI JyQueryAppInfoBySceneCode is deprecated, please use Dypnsapi::2017-05-25::QueryAppInfoBySceneCode instead.
     *
     * @param request - JyQueryAppInfoBySceneCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns JyQueryAppInfoBySceneCodeResponse
     */
    // Deprecated
    async jyQueryAppInfoBySceneCodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sceneCode)) {
            query["SceneCode"] = request.sceneCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "JyQueryAppInfoBySceneCode",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new JyQueryAppInfoBySceneCodeResponse({}));
    }
    /**
     * 根据方案号查询运营商APP信（为极意临时定制）
     *
     * @deprecated OpenAPI JyQueryAppInfoBySceneCode is deprecated, please use Dypnsapi::2017-05-25::QueryAppInfoBySceneCode instead.
     *
     * @param request - JyQueryAppInfoBySceneCodeRequest
     * @returns JyQueryAppInfoBySceneCodeResponse
     */
    // Deprecated
    async jyQueryAppInfoBySceneCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.jyQueryAppInfoBySceneCodeWithOptions(request, runtime);
    }
    /**
     * Queries the fees generated by a verification service.
     *
     * @remarks
     * ### [](#qps)QPS limits
     * You can call this operation up to 500 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryGateVerifyBillingPublicRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryGateVerifyBillingPublicResponse
     */
    async queryGateVerifyBillingPublicWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.authenticationType)) {
            query["AuthenticationType"] = request.authenticationType;
        }
        if (!tea_util_1.default.isUnset(request.month)) {
            query["Month"] = request.month;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryGateVerifyBillingPublic",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryGateVerifyBillingPublicResponse({}));
    }
    /**
     * Queries the fees generated by a verification service.
     *
     * @remarks
     * ### [](#qps)QPS limits
     * You can call this operation up to 500 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryGateVerifyBillingPublicRequest
     * @returns QueryGateVerifyBillingPublicResponse
     */
    async queryGateVerifyBillingPublic(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryGateVerifyBillingPublicWithOptions(request, runtime);
    }
    /**
     * Queries the calls of Phone Number Verification Service.
     *
     * @remarks
     * ### [](#qps)QPS limits
     * You can call this operation up to 500 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryGateVerifyStatisticPublicRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryGateVerifyStatisticPublicResponse
     */
    async queryGateVerifyStatisticPublicWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.authenticationType)) {
            query["AuthenticationType"] = request.authenticationType;
        }
        if (!tea_util_1.default.isUnset(request.endDate)) {
            query["EndDate"] = request.endDate;
        }
        if (!tea_util_1.default.isUnset(request.osType)) {
            query["OsType"] = request.osType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.sceneCode)) {
            query["SceneCode"] = request.sceneCode;
        }
        if (!tea_util_1.default.isUnset(request.startDate)) {
            query["StartDate"] = request.startDate;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryGateVerifyStatisticPublic",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryGateVerifyStatisticPublicResponse({}));
    }
    /**
     * Queries the calls of Phone Number Verification Service.
     *
     * @remarks
     * ### [](#qps)QPS limits
     * You can call this operation up to 500 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - QueryGateVerifyStatisticPublicRequest
     * @returns QueryGateVerifyStatisticPublicResponse
     */
    async queryGateVerifyStatisticPublic(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryGateVerifyStatisticPublicWithOptions(request, runtime);
    }
    /**
     * Queries the delivery status of the SMS verification code. You can query only the delivery status of the SMS verification code that is sent by calling corresponding API operations.
     *
     * @deprecated OpenAPI QuerySendDetails is deprecated
     *
     * @param request - QuerySendDetailsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySendDetailsResponse
     */
    // Deprecated
    async querySendDetailsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizId)) {
            query["BizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.phoneNumber)) {
            query["PhoneNumber"] = request.phoneNumber;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sendDate)) {
            query["SendDate"] = request.sendDate;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySendDetails",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySendDetailsResponse({}));
    }
    /**
     * Queries the delivery status of the SMS verification code. You can query only the delivery status of the SMS verification code that is sent by calling corresponding API operations.
     *
     * @deprecated OpenAPI QuerySendDetails is deprecated
     *
     * @param request - QuerySendDetailsRequest
     * @returns QuerySendDetailsResponse
     */
    // Deprecated
    async querySendDetails(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySendDetailsWithOptions(request, runtime);
    }
    /**
     * Sends SMS verification codes.
     *
     * @param request - SendSmsVerifyCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendSmsVerifyCodeResponse
     */
    async sendSmsVerifyCodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.codeLength)) {
            query["CodeLength"] = request.codeLength;
        }
        if (!tea_util_1.default.isUnset(request.codeType)) {
            query["CodeType"] = request.codeType;
        }
        if (!tea_util_1.default.isUnset(request.countryCode)) {
            query["CountryCode"] = request.countryCode;
        }
        if (!tea_util_1.default.isUnset(request.duplicatePolicy)) {
            query["DuplicatePolicy"] = request.duplicatePolicy;
        }
        if (!tea_util_1.default.isUnset(request.interval)) {
            query["Interval"] = request.interval;
        }
        if (!tea_util_1.default.isUnset(request.outId)) {
            query["OutId"] = request.outId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.phoneNumber)) {
            query["PhoneNumber"] = request.phoneNumber;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.returnVerifyCode)) {
            query["ReturnVerifyCode"] = request.returnVerifyCode;
        }
        if (!tea_util_1.default.isUnset(request.schemeName)) {
            query["SchemeName"] = request.schemeName;
        }
        if (!tea_util_1.default.isUnset(request.signName)) {
            query["SignName"] = request.signName;
        }
        if (!tea_util_1.default.isUnset(request.smsUpExtendCode)) {
            query["SmsUpExtendCode"] = request.smsUpExtendCode;
        }
        if (!tea_util_1.default.isUnset(request.templateCode)) {
            query["TemplateCode"] = request.templateCode;
        }
        if (!tea_util_1.default.isUnset(request.templateParam)) {
            query["TemplateParam"] = request.templateParam;
        }
        if (!tea_util_1.default.isUnset(request.validTime)) {
            query["ValidTime"] = request.validTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SendSmsVerifyCode",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SendSmsVerifyCodeResponse({}));
    }
    /**
     * Sends SMS verification codes.
     *
     * @param request - SendSmsVerifyCodeRequest
     * @returns SendSmsVerifyCodeResponse
     */
    async sendSmsVerifyCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.sendSmsVerifyCodeWithOptions(request, runtime);
    }
    /**
     * Verifies the phone number that you use.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Getting Started](https://help.aliyun.com/document_detail/84541.html).
     * >  This operation is applicable to only the verification of thephone number that you use. To obtain a phone number for one-click logon, call [GetMobile](https://help.aliyun.com/document_detail/189865.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 5,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - VerifyMobileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns VerifyMobileResponse
     */
    async verifyMobileWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accessCode)) {
            query["AccessCode"] = request.accessCode;
        }
        if (!tea_util_1.default.isUnset(request.outId)) {
            query["OutId"] = request.outId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.phoneNumber)) {
            query["PhoneNumber"] = request.phoneNumber;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "VerifyMobile",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new VerifyMobileResponse({}));
    }
    /**
     * Verifies the phone number that you use.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Getting Started](https://help.aliyun.com/document_detail/84541.html).
     * >  This operation is applicable to only the verification of thephone number that you use. To obtain a phone number for one-click logon, call [GetMobile](https://help.aliyun.com/document_detail/189865.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 5,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - VerifyMobileRequest
     * @returns VerifyMobileResponse
     */
    async verifyMobile(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.verifyMobileWithOptions(request, runtime);
    }
    /**
     * Verifies the phone number used in HTML5 pages.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Use the phone number verification feature for HTML5 pages](https://help.aliyun.com/document_detail/169786.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - VerifyPhoneWithTokenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns VerifyPhoneWithTokenResponse
     */
    async verifyPhoneWithTokenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.phoneNumber)) {
            query["PhoneNumber"] = request.phoneNumber;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.spToken)) {
            query["SpToken"] = request.spToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "VerifyPhoneWithToken",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new VerifyPhoneWithTokenResponse({}));
    }
    /**
     * Verifies the phone number used in HTML5 pages.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Use the phone number verification feature for HTML5 pages](https://help.aliyun.com/document_detail/169786.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 1,000 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - VerifyPhoneWithTokenRequest
     * @returns VerifyPhoneWithTokenResponse
     */
    async verifyPhoneWithToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.verifyPhoneWithTokenWithOptions(request, runtime);
    }
    /**
     * Verifies SMS verification codes.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Use the SMS verification feature](https://help.aliyun.com/document_detail/313209.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 500 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - VerifySmsCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns VerifySmsCodeResponse
     */
    async verifySmsCodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.phoneNumber)) {
            query["PhoneNumber"] = request.phoneNumber;
        }
        if (!tea_util_1.default.isUnset(request.smsCode)) {
            query["SmsCode"] = request.smsCode;
        }
        if (!tea_util_1.default.isUnset(request.smsToken)) {
            query["SmsToken"] = request.smsToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "VerifySmsCode",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new VerifySmsCodeResponse({}));
    }
    /**
     * Verifies SMS verification codes.
     *
     * @remarks
     * ### [](#)Preparations
     * You must register an Alibaba Cloud account, obtain an Alibaba Cloud AccessKey pair, and create a verification service. For more information, see [Use the SMS verification feature](https://help.aliyun.com/document_detail/313209.html).
     * ### [](#qps)QPS limits
     * You can call this operation up to 500 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *
     * @param request - VerifySmsCodeRequest
     * @returns VerifySmsCodeResponse
     */
    async verifySmsCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.verifySmsCodeWithOptions(request, runtime);
    }
    /**
     * Obtains the verification results by using the verification token that is obtained by using the authentication token.
     *
     * @param request - VerifyWithFusionAuthTokenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns VerifyWithFusionAuthTokenResponse
     */
    async verifyWithFusionAuthTokenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.verifyToken)) {
            query["VerifyToken"] = request.verifyToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "VerifyWithFusionAuthToken",
            version: "2017-05-25",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new VerifyWithFusionAuthTokenResponse({}));
    }
    /**
     * Obtains the verification results by using the verification token that is obtained by using the authentication token.
     *
     * @param request - VerifyWithFusionAuthTokenRequest
     * @returns VerifyWithFusionAuthTokenResponse
     */
    async verifyWithFusionAuthToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.verifyWithFusionAuthTokenWithOptions(request, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map